
# Why doing TDD with Android is challenging

## How a unit test is done

The usual way to write a unit test for a Java object is to

 0. create the object, bringing it to a desired state
 1. perform an action on it
 2. assert the state of the object, or the state of its collaborators.

There are two ways to accomplish the first step.  The first way is to pass the required state in the constructor.

    Dictionary dictionary = new Dictionary("cat", "gatto", "dog", "cane");

The second is to create the object in a default state, and then modify it.

    Dictionary dictionary = new Dictionary();
    dictionary.define("cat", "gatto");
    dictionary.define("dog", "cane");

## Android problem #1: the OS does the instantiating

In Android, all of the important objects: the Activity, the Views, the Services, the Content providers, are instantiated by the system.  This makes it very difficult to do a unit test on such objects, because we cannot even instantiate the objects; we must get the OS to instantiate them for us.

The solution: don't try to unit test them.  Regard them as a kind of "main" program.

### A non-Android example

Let's illustrate the principle with an example.  You have a simple Java program that reads a text file from standard input, and outputs the same file with line numbers in front.  The program, being so simple, can be written as a single "main" program, like this:

    public class LineNumbersFilter {
      public static void main(String ... args) throws IOException {
        String line;
        int count = 0;
        BufferedReader reader =
          new BufferedReader(new InputStreamReader(System.in));
        while ((line = reader.readLine()) != null) {
          count++;
          System.out.println(String.format("%d %s", count, line));
        }
      }
    }

It's extremely difficult to unit test this program.  The difficulty lies in the fact that the program accesses `System.in` and `System.out` directly.  It's difficult to set up the contents of System.in within a unit test, and it's difficult to check the contents of System.out in a unit test.  You might try, but it's going to be messy, and very *expensive* in terms of your time.

On the other hand, if you break down the program in two parts, the "main" part and the "logic" part, you will find that the logic can be unit tested easily.

    class LineNumbersFilter {
      private InputStream in;
      private PrintStream out;

      public LineNumbersFilter(InputStream in, PrintStream out) {
        this.in = in;
        this.out = out;
      }

      public void apply() throws IOException {
        String line;
        int count = 0;
        BufferedReader reader =
          new BufferedReader(new InputStreamReader(in));
        while ((line = reader.readLine()) != null) {
          count++;
          out.println(String.format("%d %s", count, line));
        }
      }
      // The "logic" part is above

      // The "main"  part is below
      public static void main(String ... args) throws IOException {
        LineNumbersFilter filter = new LineNumbersFilter(System.in, System.out);
        filter.apply();
      }
    }

Now we can set up the LineNumbersFilter with in-memory streams, that can be easily constructed and checked within a unit test.

    @Test
    public void oneLineOfInput() throws Exception {
      ByteArrayInputStream inputStream =
            new ByteArrayInputStream("one line".getBytes());
      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
      PrintStream printStream = new PrintStream(outputStream);

      new LineNumbersFilter(inputStream, printStream).apply();

      assertEquals("1 one line\n", outputStream.toString());
    }

You may object: "you are saying that there is no way to test main, and we risk letting defects seep into our main".  We have two answers for this.

The first answer is that if we properly separate logic from creation, there will be no "IFs" in the main.  So it will be easy to check by hand that it works; a single manual test will do it.  In other words: if there is an error in the main, it will be readily apparent as soon as we try to run it.

The second answer is that it's actually quite easy to do an **end-to-end** test of the main.  The Bash script below does it quite nicely.

{lang="bash"}
    cat > /tmp/expected.txt <<EOF
    1 first line
    2 second line
    EOF

    java LineNumbersFilter > /tmp/actual.txt <<EOF
    first line
    second line
    EOF

    if diff /tmp/expected.txt /tmp/actual.txt > /tmp/difference.txt
    then
      echo "ok"
    else
      echo "ERROR:"; cat /tmp/difference.txt
    fi

This, however, is not a unit test.  It does not test "main" by itself; it tests everything.  It can be a very good thing to write such an end-to-end test, so that we can automatically check that the program performs as expected.  However, such tests usually take a long time to write, and it usually takes a long time to get them to pass.  For this reason, although they can be very useful in general, they are not very useful for TDD.


### What's the consequence for Android programmers

In Android, we can't just instantiate Activities or Views.  We must let the system instantiate them for us.  Therefore it's not practical to unit-test them.  So we don't!  We treat the Activity, View, Service or Content Provider as **our "main"**.  We take care to move all the logic away from them, into objects that we can create as we please.


## Android problem #2: all tests run on the device

The second big problem is that all the tooling that goes with Android assumes that the JUnit tests will run *inside the device*.  We a
